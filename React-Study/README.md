
### React 学习线路

- React UI库

- Redux

- Flux

- Babel

- webpack

---

#### React UI库

##### 组件

- 组件生命周期

- Presentational Components and Container Components

```


Presentational Components Container Components
Purpose How things look (markup, styles)  How things work (data fetching, state updates)
Aware of Redux  No  Yes
To read data  Read data from props  Subscribe to Redux state
To change data  Invoke callbacks from props Dispatch Redux actions
Are written By hand Usually generated by React Redux
```

##### [Thinking in React](https://facebook.github.io/react/docs/thinking-in-react.html)

One of the many great parts of React is how it makes you think about apps as you build them

One such technique is the single responsibility principle, that is, a component should ideally only do one thing.

You can build top-down or bottom-up.

In simpler examples, it's usually easier to go top-down, and on larger projects, it's easier to go bottom-up and write tests as you build.

you first need to think of the minimal set of mutable state that your app needs. The key here is DRY: Don't Repeat Yourself. Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand. For example, if you're building a TODO list, just keep an array of the TODO items around; don't keep a separate state variable for the count. Instead, when you want to render the TODO count, simply take the length of the TODO items array.


##### 虚拟DOM

##### View Controller

[view-controller](http://blog.andrewray.me/the-reactjs-controller-view-pattern/)


##### 纯React UI库的使用心得

- 虚拟DOM

  - 所有挂载在真实DOM节点之前的DOM元素都是虚拟DOM
  - 虚拟DOM就是一种具备DOM结构的JavaScript的数据类型
  - 操作虚拟DOM与真实DOM的区别在于：
    - 操作虚拟DOM就是进行JS的数据变化
    - 操作真实DOM则是进行视图的重绘
  - 因此，虚拟DOM的性能优势在于利用JS解释器的高效计算替代真实DOM的重绘成本，重绘与运算相比开销更大；

- 代码逻辑

  用户 -> views -> state
      <-  views <- state

#### Flux

**Flux Profile**

APPLICATION ARCHITECTURE FOR BUILDING USER INTERFACES

**Attributes**

- a pattern for managing data flow

- unidirectional cycles

dispatcher是是事件调度程序（一个对象），它在action中定义事件触发程序，在store中定义事件注册程序；

整个架构的运转逻辑是view层进行交互触发actions的事件分发程序，store层接收事先定义的事件触发回调；

store的变化重置app的state，视图进行重绘；

store的重绘具体逻辑：

1. actions改变store (store与state进行联系)
2. 然后emit change event
3. view监听change, 触发后state重置而进行视图重绘


**Flux Parts**

- Action

- Dispatcher

- Store

- View

![](https://github.com/facebook/flux/raw/master/examples/flux-concepts/flux-simple-f8-diagram-with-client-action-1300w.png)

- Dispathcher

receives actions and dispatches them to stores that have registered with the dispatcher

There should be only one singleton dispatcher in each application.

```
const TodoAction = {
  create(todo) {
    AppDispatcher.dispatch({
      actionType: 'CREATE_TODO',
      todo
    });
  },
  delete(id) {
    AppDispatcher.dispatch({
      actionType: 'DELETE_TODO',
      id
    });
  }
};
```

```
AppDispatcher.register((action) => {
  switch (action.actionType) {
    case 'CREATE_TODO':
      TodoStore.addTodo(action.todo);
      TodoStore.emitChange();
      break;
    case 'DELETE_TODO':
      TodoStore.deleteTodo(action.id);
      TodoStore.emitChange();
      break;
    default:
      //  nothing to do here

  }
});
```

Dispatcher tips

Callbacks are not subscribed to particular events. Every payload is dispatched to every registered callback.
Callbacks can be deferred in whole or part until other callbacks have been executed.

- Store

holds the data of an application

store register the event dispatched from actions

data in a store only be mutated by responding to an action

data changes it must emit a 'change' event

Key Concept: A store is not a model. A store contains models

Key concept: A store is the only thing in your application that knows how to update data. This is the most important part of Flux. The action we dispatched doesn't know how to add or remove items.

Only your stores are allowed to register dispatcher callbacks! Your views should never call AppDispatcher.register

Key Concept: We don't pass the newest item when we trigger. Our views only care that something changed.

- Actions

capture the ways in which anything might interact with your application.

objects that have a "type" field and some data.

```
const TodoAction = {
  create(todo) {
    AppDispatcher.dispatch({
      actionType: 'CREATE_TODO',
      todo
    });
  },
  delete(id) {
    AppDispatcher.dispatch({
      actionType: 'DELETE_TODO',
      id
    });
  }
};
```

Actions should be semantic and descriptive of the action

should not describe implementation details of that action. Use "delete-user" rather than breaking it up into "delete-user-id", "clear-user-data", "refresh-credentials" 

What The Hell Is An "Action Creator"?



- Views

Data from stores is displayed in views

Views can use whatever framework

 When a view uses data from a store it must also subscribe to change events from that store.


 ```
  componentDidMount() {
    TodoStore.addChangeListener(this.onChange);
  }
  componentWillUnmount() {
    TodoStore.removeChangeListener(this.onChange);
  }
  onChange() {
    this.setState({
      todos: TodoStore.getAll()
    });
  }
 ```

 Key Concept: When store data changes, your views shouldn't care if things were added, deleted, or modified. They should just re-render entirely. React's "virtual DOM" diff algorithm handles the heavy lifting of figuring out which real DOM nodes changed. This makes your life much simpler, and will lower your blood pressure.

 - example

 Example:

The main view subscribes to the TodoStore.
It accesses a list of the Todos and renders them in a readable format for the user to interact with.
When a user types in the title of a new Todo and hits enter the view tells the Dispatcher to dispatch an action.
All stores receive the dispatched action.
The TodoStore handles the action and adds another Todo to its internal data structure, then emits a "change" event.
The main view is listening for the "change" event. It gets the event, gets new data from the TodoStore, and then re-renders the list of Todos in the user interface.

Views send actions to the dispatcher.
The dispatcher sends actions to every store.
Stores send data to the views.

**Flux Practice**

```
import { Dispatcher } from 'flux';

```

```
import EventEmitter from 'events';
```

---

#### Redux

![Redux](https://camo.githubusercontent.com/f28b5bc7822f1b7bb28a96d8d09e7d79169248fc/687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67)

##### What is Redux ?

Redux is a predictable state container for JavaScript apps.

It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test.

##### Motivation

JavaScript single-page applications have become increasingly complicated, our code must manage more state than ever before. 

- what state includes ?

	- server responses
	- cached data
	- created by locally that has not yet been persisted to the server
	- UI state
	- routes

##### Redux Function

React attempt to  solve this problem in the view layer by removing both asynchrony and direct DOM manipulation.

- **Core Concepts**

reducer(function): to tie state and actions together

it’s just a function that takes state and action as arguments, and returns the next state of the app


- **state**

your app’s state is described as a plain object,For example, the state of a todo app might look like this:
This object is like a “model” except that there are no setters.

```
{
  todos: [{
    text: 'Eat food',
    completed: true
  }, {
    text: 'Exercise',
    completed: false
  }],
  visibilityFilter: 'SHOW_COMPLETED'
}
```

- **action**

To change something in the state, you need to dispatch an action. An action is a plain JavaScript object 

```
{ type: 'ADD_TODO', text: 'Go to swimming pool' }
{ type: 'TOGGLE_TODO', index: 1 }
{ type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }
```
- **reducer**


 to tie state and actions together, we write a function called a reducer. 

it’s just a function that takes state and action as arguments, and returns the next state of the app.


 It would be hard to write such a function for a big app, so we write smaller functions managing parts of the state:

 ```
function visibilityFilter(state = 'SHOW_ALL', action) {
  if (action.type === 'SET_VISIBILITY_FILTER') {
    return action.filter;
  } else {
    return state;
  }
}

function todos(state = [], action) {
  switch (action.type) {
  case 'ADD_TODO':
    return state.concat([{ text: action.text, completed: false }]);
  case 'TOGGLE_TODO':
    return state.map((todo, index) =>
      action.index === index ?
        { text: todo.text, completed: !todo.completed } :
        todo
   )
  default:
    return state;
  }
}
 ```
write another reducer that manages the complete state of our app by calling those two reducers for the corresponding state keys

```
function todoApp(state = {}, action) {
  return {
    todos: todos(state.todos, action),
    visibilityFilter: visibilityFilter(state.visibilityFilter, action)
  };
}
```
##### Three Principles

- Single source of truth

The state of your whole application is stored in an object tree within a single store.

```
console.log(store.getState())

/* Prints
{
  visibilityFilter: 'SHOW_ALL',
  todos: [
    {
      text: 'Consider using Redux',
      completed: true,
    },
    {
      text: 'Keep all state in a single tree',
      completed: false
    }
  ]
}
*/
```

- State is read-only

The only way to change the state is to emit an action, an object describing what happened.

 ensures that neither the views nor the network callbacks will ever write directly to the state,

 express an intent to transform the state.

```
store.dispatch({
  type: 'COMPLETE_TODO',
  index: 1
})

store.dispatch({
  type: 'SET_VISIBILITY_FILTER',
  filter: 'SHOW_COMPLETED'
})
```
- Changes are made with pure functions——Reducers

To specify how the state tree is transformed by actions, you write pure reducers.

Reducers are just pure functions that take the previous state and an action, and return the next state. Remember to return new state objects, instead of mutating the previous state. You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree

##### Redux && Flux

Redux was inspired by several important qualities of Flux.

Redux prescribes that you concentrate your model update logic in a certain layer of your application (“stores” in Flux, “reducers” in Redux). Instead of letting the application code directly mutate the data, both tell you to describe every mutation as a plain object called an “action”.

Unlike Flux, Redux does not have the concept of a Dispatcher. This is because it relies on pure functions instead of event emitters, and pure functions are easy to compose and don't need an additional entity managing them.

nother important difference from Flux is that Redux assumes you never mutate your data. You can use plain objects and arrays for your state just fine, but mutating them inside the reducers is strongly discouraged. You should always return a new object


##### Actions

Actions are payloads of information that send data from your application to your store. They are the only source of information for the store.

```
const ADD_TODO = 'ADD_TODO';

export {
  type: ADD_TODO,
  text: 'Build my first Redux app'
}
```
Actions are plain JavaScript objects. Actions must have a type property that indicates the type of action being performed. Types should typically be defined as string constants

- Action Creators

Action creators are exactly that—functions that create actions

In Redux action creators simply return an action:

```
function addTodo(text) {
  return {
    type: ADD_TODO,
    text
  }
}
```
- Different between Flux and Redux about action creator

Flux

```
function addTodoWithDispatch(text) {
  const action = {
    type: ADD_TODO,
    text
  }
  dispatch(action)
}
```
In Redux this is not the case.
Instead, to actually initiate a dispatch, pass the result to the dispatch() function:

```
dispatch(addTodo(text))
dispatch(completeTodo(index))

// or create a bound action creator that automatically dispatches:

const boundAddTodo = (text) => dispatch(addTodo(text))
const boundCompleteTodo = (index) => dispatch(completeTodo(index))

boundAddTodo(text)
boundCompleteTodo(index)
```
##### Reducers

Actions describe the fact that something happened,but don't specify how the application's state changes in response. 

##### Store

In the previous sections, we defined the actions that represent the facts about “what happened” and the reducers that update the state according to those actions.

The Store is the object that brings them together.

The store has the following responsibilities:

Holds application state;
Allows access to state via getState();
Allows state to be updated via dispatch(action);
Registers listeners via subscribe(listener);
Handles unregistering of listeners via the function returned by subscribe(listener).

It's important to note that you'll only have a single store in a Redux application

When you want to split your data handling logic, you'll use reducer composition instead of many stores.

- how to create Store

we used combineReducers() to combine several reducers into one. We will now import it, and pass it to createStore().

```
import { createStore } from 'redux'
import todoApp from './reducers'
let store = createStore(todoApp)
```

- Dispatch Actions

```
import { addTodo, toggleTodo, setVisibilityFilter, VisibilityFilters } from './actions'

// Log the initial state
console.log(store.getState())

// Every time the state changes, log it
// Note that subscribe() returns a function for unregistering the listener
let unsubscribe = store.subscribe(() =>
  console.log(store.getState())
)

// Dispatch some actions
store.dispatch(addTodo('Learn about actions'))
store.dispatch(addTodo('Learn about reducers'))
store.dispatch(addTodo('Learn about store'))
store.dispatch(toggleTodo(0))
store.dispatch(toggleTodo(1))
store.dispatch(setVisibilityFilter(VisibilityFilters.SHOW_COMPLETED))

// Stop listening to state updates
unsubscribe()
```
- Presentational and Container Component

Most of the components we'll write will be presentational, but we'll need to generate a few container components to connect them to the Redux store.

##### Usage with React

难点：

index.js

```
import React from 'react'
import { render } from 'react-dom'
import { createStore } from 'redux'
import { Provider } from 'react-redux'
import App from './containers/App'
import todoApp from './reducers'

let store = createStore(todoApp)

let rootElement = document.getElementById('root')
render(
  <Provider store={store}>
    <App />
  </Provider>,
  rootElement
)
```

---
参考资料
[Flux-docs](http://facebook.github.io/flux/docs)
[Flux-examples](https://github.com/facebook/flux/tree/master/examples)
[flux-for-stupid-people](http://blog.andrewray.me/flux-for-stupid-people/)
[getting-started-with-redux](https://egghead.io/courses/getting-started-with-redux)
[同构应用](http://www.csdn.net/article/2015-02-26/2824023)
[Presentational and Container Component](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)
[](http://redux.js.org/docs/basics/UsageWithReact.html)